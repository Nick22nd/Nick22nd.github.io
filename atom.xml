<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nick22nd</title>
  
  
  <link href="https://nick22nd.me/atom.xml" rel="self"/>
  
  <link href="https://nick22nd.me/"/>
  <updated>2025-01-28T14:54:35.786Z</updated>
  <id>https://nick22nd.me/</id>
  
  <author>
    <name>Nick22nd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024 年的年终总结</title>
    <link href="https://nick22nd.me/posts/summary-of-2024/"/>
    <id>https://nick22nd.me/posts/summary-of-2024/</id>
    <published>2025-01-28T14:01:02.000Z</published>
    <updated>2025-01-28T14:54:35.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="混沌与重新起航"><a href="#混沌与重新起航" class="headerlink" title="混沌与重新起航"></a>混沌与重新起航</h2><p>想了许久，不知该从何写起;</p><p>逃避，重启，虚无，放弃。</p><p>我有点难以面对真实的 2024. 直接开始下半年的记录吧。我开始了一份新工作，一开始强度远远超过我的预期，到差点两个月就离职跑路了，虽然收入也是高于之前的水平。但是这并非我所想的，比起这样的需要承担更多的职位，我情愿当一个纯粹的开发，哪怕是少一点钱。我也愈发厌恶这样连续不断，且毫无休止的社会期望。按部就班的上学，工作，买房，结婚生子，我无力改变外部环境，我就只能改变自己或者更换环境，就像其他各种各类的社会衍生的物品; 当前没有离开只是没被铁拳打痛，没能有必走的决心而已，但是感觉逐渐成为“异类”以及不愿继续表演的我，离开只是时间的早晚。</p><p>5 月之后我就决定去进行买房的准备了，哪怕是从 0 开始的积累。这时候才明白我消耗的 20 个月是多么昂贵。不过并不会太后悔，只不过时间略长。而且塞翁失马，正常工作也不一定有这样的涨幅。但是从社会大众角度而言这么长时间的空窗期无疑是一个失败的决定，在当代的就业市场更是和犯罪记录一样。但是这终究是我自己的生活和决定，我觉得还不错，而且算是体验了一段独一无二的生活，了解了自己并不适合这种生活。</p><h2 id="有趣的事物"><a href="#有趣的事物" class="headerlink" title="有趣的事物"></a>有趣的事物</h2><p>《黑神话悟空》，超出预期的优秀，当然除了最后一章;音乐和美术远超预期，让人享受其中，几个动画也是让我感受到了游戏作为内容载体的了不起的地方。</p><p>《赤心巡天》，颇为不错的网文，开头实在是劝退人，还有就是太长了，复仇主线中间插入了太多副本，到了后期感觉也是有些收不住，但是前中期足够优秀，更重要的感受到作者的真诚。</p><p>好像还真没有什么了特殊的文娱作品了</p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>去查看了下 github, 贡献虽然很少，但是比起啥也没有强不少，确实也算是在 AI 的浪潮中贡献了几颗小水珠。</p><h2 id="新年的计划"><a href="#新年的计划" class="headerlink" title="新年的计划"></a>新年的计划</h2><p>会在 AI 领域投入更多精力，去学习基础知识然后在社区能解决一些实际的问题，如果允许会尝试转换职业方向到 AI 领域，面对这个时代的浪潮实在很难抗拒，无论是职业发展还是自己的好奇心，哪怕是个巨大的泡沫，但是当前的成果和应用依然让人着迷。</p><p>会继续做现在掌握 web 技术栈 (electron, 浏览器插件，SEO) 相关的产品</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;混沌与重新起航&quot;&gt;&lt;a href=&quot;#混沌与重新起航&quot; class=&quot;headerlink&quot; title=&quot;混沌与重新起航&quot;&gt;&lt;/a&gt;混沌与重新起航&lt;/h2&gt;&lt;p&gt;想了许久，不知该从何写起;&lt;/p&gt;
&lt;p&gt;逃避，重启，虚无，放弃。&lt;/p&gt;
&lt;p&gt;我有点难以面对真实</summary>
      
    
    
    
    <category term="生活" scheme="https://nick22nd.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="总结" scheme="https://nick22nd.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>《艾尔登法环》通关体验</title>
    <link href="https://nick22nd.me/posts/elden-ring/"/>
    <id>https://nick22nd.me/posts/elden-ring/</id>
    <published>2022-03-23T08:17:38.000Z</published>
    <updated>2024-06-02T11:07:32.912Z</updated>
    
    <content type="html"><![CDATA[<p>3.23 达成群星时代的结局，虽然女武神支线尚未完成，以及还有不少小地区没来得及探索，但是游戏进度也算是告一段落了。这里作为一名普通玩家也想来记录自己的体验感想。</p><h2 id="游戏过程"><a href="#游戏过程" class="headerlink" title="游戏过程"></a>游戏过程</h2><ul><li>游戏很早就购买了，本来打算请假体验的，但是奈何工作忙挤不出时间，只有等到周末才开始游玩（终于体会到工作党玩家的心酸了）。我虽然早就听说法师开局是最简单的， 不过出于魂三的初次开局骑士的回忆，决定继续先试试骑士，没想到这直接就是hard模式的开始。<br><img src="/images/elden-ring-knight.jpeg" alt="elden-ring-knight"></li><li>我开局的比较特别，习惯性走的是侧边，所以根本没碰到大树守卫，拿到灵马后简单探索了附近的地区，适应了下战斗系统。然后又因为先走侧边的习惯，绕过了史东威尔城，过了断桥直接到了湖畔断崖，还奇怪史东威尔城那里的王座怎么是空的，入口在哪。不过继续沿着路终于找到了npc，获得了学院的线索。在寻找钥匙的过程中，还探索了不少的地图，古遗迹很早就推到了歌唱蝙蝠那里，作为近战完全没有思路怎么处理。找到钥匙后，开始探索学院，所以我第一个大地图探索的是魔法学院，作为一个低等级骑士，在全是法师的地图疯狂受苦，同时也感受到了法师的远程的便利，加上卡了好几个地方的boss，决定从智力9加点转法师。反正要转法师，所以边探索边加点呗，继续开新地图龙墓，神授塔，盖利德，安瑟河，卡了不少boss。</li><li>然后没忍住看了一波喂狗组佩奇的玻璃大炮法师思路，发现陨石杖和陨石法术位置居然还挺近，就过去拿到了这两件前期神器，同时也结束我的大戟骑士的受苦生涯，开始了肉盾法师的幸福之路。刷点到了陨石术最低条件，加上魔法学院探索得到的头部装备，狂清之前的卡关boss和精英怪。虽然我都已经在亚坛高原上探索地图， 但依然还未找到史东威尔城入口。</li><li>拿到陨石术后，boss战开始变得千篇一律，简单到有些无聊。当然探索新地图还是很有趣的，上火山，王城外围，史东威尔城。卡了很久的boss就是龙装大树守卫，一发雷电就是丝血，只能背板，然后用魔法辉剑磨死，主要是等级太低了。还有魔法到了中后期推图有些困难，没有合适蓝耗的魔法。还有火山坠星兽，都是落地一头秒杀，直到有一天起飞的过程看到了一个地方两个石头靠得非常近，原来不是必打的boss，直接跳过到火山官邸打工直到雪原的暗杀人物，之后又是随缘探索打完碎星，然后才去探索的卡利亚城，做了拉妮的支线，又是为拉妮打工，探索永恒之城和深根地区。啜泣半岛太晚去，数值碾压以至于完全没有压力。另外王城地图实在是太难探索了，小怪伤害高，人均魔法祷告，赐福点间隔远，Boss完全没有什么压迫感。到了雪原，火焰巨人真的是法师的噩梦，卡了实在太久，真的是花了巨大心血找黑刀骨灰，收集材料升级骨灰，找法师近战武器名刀，升级武器，还顺便把鲜血王朝任务清了。只能说黑刀是 真·艾尔登之王，百分比伤害，褪色者岩石球吸引boss火力持盾挡伤害，后期boss基本靠黑刀输出，除非是能稳定吃到灵魂激流。</li></ul><h2 id="让人满意的地方"><a href="#让人满意的地方" class="headerlink" title="让人满意的地方"></a>让人满意的地方</h2><h3 id="一脉相承"><a href="#一脉相承" class="headerlink" title="一脉相承"></a>一脉相承</h3><ul><li>华丽的boss演出，碎星最为突出</li><li>游戏氛围营造和美术风格，让人带入感极强</li><li>精致的箱庭地图，”柳暗花明又一村”的惊喜感</li><li>有特色的怪物和叙事风格</li></ul><h3 id="新的优点"><a href="#新的优点" class="headerlink" title="新的优点"></a>新的优点</h3><ul><li>骨灰降低了难度</li><li>增加了人物跳跃和坐骑</li><li>开放世界，不局限于卡关在某一个Boss处，可以通过探索其他地区变强，后续来攻略</li><li>庞大的地图体量</li></ul><h3 id="让人感觉糟糕的地方"><a href="#让人感觉糟糕的地方" class="headerlink" title="让人感觉糟糕的地方"></a>让人感觉糟糕的地方</h3><ul><li>精英怪和Boss读指令问题实在是破坏了战斗体验，中距离下魔法一出手必定翻滚，部分boss喝血瓶必定攻击</li><li>前期骑士等近战伤害远远低于法师，战斗风险和收益完全不对等</li><li>部分信息指引实在是很糟糕，很容易错过NPC支线，对话中的线索全靠记忆，关键道具提示太少。比如白金之子的秘密符节，如果早期探索该地区错过，后期拿到另外一半时完全没有提示，只能搜索攻略。</li><li>等级优势后，前期Boss战斗显得很无聊（这个谈不上糟糕，只不过开放世界数值设定的取舍问题）</li></ul><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><ul><li>十分优秀的游戏，非常值得一玩，个别地方稍有糟心的点，但是瑕不掩瑜。期待FS社的下一部作品。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3.23 达成群星时代的结局，虽然女武神支线尚未完成，以及还有不少小地区没来得及探索，但是游戏进度也算是告一段落了。这里作为一名普通玩家也想来记录自己的体验感想。&lt;/p&gt;
&lt;h2 id=&quot;游戏过程&quot;&gt;&lt;a href=&quot;#游戏过程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="游戏" scheme="https://nick22nd.me/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="https://nick22nd.me/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="评价" scheme="https://nick22nd.me/tags/%E8%AF%84%E4%BB%B7/"/>
    
  </entry>
  
  <entry>
    <title>2021年的年终总结</title>
    <link href="https://nick22nd.me/posts/summary-of-2020/"/>
    <id>https://nick22nd.me/posts/summary-of-2020/</id>
    <published>2022-01-14T17:01:02.000Z</published>
    <updated>2024-06-02T11:08:08.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Life"><a href="#Life" class="headerlink" title="Life"></a>Life</h2><p>看了下2020年的年终总结, 有点奇妙的感觉. 2021读了新的书, 有了新的思考, 也做了之前从未进行的尝试, 也有了新的烦恼. </p><p>这一年感觉像是全新的开始, 3月份换了新的工作, 进入了被称为”互联网”类型的公司. 年轻的同事, 快速的节奏, 还算新的技术, 对我而言的确颇为新奇. 值得感概的是, 虽然并不完美,  但终于有正经的开发流程. 自己作为不同的角色来感受一个项目被推进的, 最终实现的过程, 这的确帮助我学习并理解到了许多沟通交流, 解决问题的思路. 同时也印证了许多读过的道理.</p><p>不过最令人高兴的是工作中碰到许多有趣的同事, 并且都算得上是朋友, 一起吃饭, 玩游戏, 登山. 连团建也不像大多数所说的无聊活动, 而是很单纯地一起去玩.  友好互助的人员氛围, 这大概是最让我满意的一点.</p><h3 id="喜欢的电影"><a href="#喜欢的电影" class="headerlink" title="喜欢的电影"></a>喜欢的电影</h3><p>应该是&lt;卧虎藏龙&gt;, 优秀的配乐, 最后一跳的结局和竹林飘过的镜头让人难忘</p><p>&lt;发条橙&gt;略微有些不适,  但十分精彩, 导演-库布里克和配乐-莫里康内都是有意思的人</p><p>今年第N次尝试学习绘画未果, 趁着生日入了电钢, 希望能点开新的技能树, 目前看来似乎还抱有较大兴趣, 不至于让琴吃灰.</p><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>只能说我的确不喜欢这样的生活, 早出晚归, 挫败感很强, 没有成就感. </p><p>我希望有更多的个人时间去学习新的技能, 参与开源项目, 获得成就感, 或者做些自己热爱或者可能热爱的事情, . 如果一份工作薪酬高并不能给我足够的时间, 那么恐怕也很快就会厌恶离开. </p><blockquote><p>雨很大, 路上的积水有点深, 基本绝了去大厂卷996的念想. 一切以跑路为第一优先级.”</p><p>–某个凌晨的雨夜</p></blockquote><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><p>技术上回想起来颇为羞愧, 今年并没有什么进步, 只不过学会了并不喜欢的小程序开发(并非我的规划内). 厚着脸皮成为了开源项目committer, 然后就没有继续提交了, 有些对不住提名和投票的PMC. 我对许多技术依然抱有热情, 关注着一些动态,  但是有时下班返回住处, 打开IDE真的有些厌倦. 就像曾经喜欢的游戏一样, 看游戏视频的时间超过了游玩的时间. </p><p>然后很多之前的学习都停滞不前, 有时候也会怀疑自己是不是叶公好龙. 希望新的一年里能完成这些的内容的学习, 用自己的技术做更多有趣的事情, 能顺便帮助到其他人就更好了 : - ). </p><ul><li>Swift&#x2F;SwiftUI</li><li>ReactNative</li><li>GAMES101 and C++</li><li>Echarts and <The Grammar of Graphics></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Life&quot;&gt;&lt;a href=&quot;#Life&quot; class=&quot;headerlink&quot; title=&quot;Life&quot;&gt;&lt;/a&gt;Life&lt;/h2&gt;&lt;p&gt;看了下2020年的年终总结, 有点奇妙的感觉. 2021读了新的书, 有了新的思考, 也做了之前从未进行的尝试, 也有了新的</summary>
      
    
    
    
    <category term="生活" scheme="https://nick22nd.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="总结" scheme="https://nick22nd.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>译-在Web上构建专业的设计工具-Figma</title>
    <link href="https://nick22nd.me/posts/building-a-professional-design-tool-on-the-web/"/>
    <id>https://nick22nd.me/posts/building-a-professional-design-tool-on-the-web/</id>
    <published>2021-01-11T13:45:51.000Z</published>
    <updated>2024-05-27T11:00:34.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="译-在Web上构建专业的设计工具"><a href="#译-在Web上构建专业的设计工具" class="headerlink" title="[译]在Web上构建专业的设计工具"></a>[译]在Web上构建专业的设计工具</h1><p><a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">原文地址</a> <a href="https://twitter.com/evanwallace">Evan Wallace</a>, CTO at Figma发布于2015年12月7日 （C：译者注释）</p><p>我们对未来设计工具的愿景是任何平台的任何人， 都可以轻松地利用设计工具和使用设计内容。这就是我们为什么将<a href="https://www.figma.com/">Figma</a>,（一个协作式界面设计工具）构建为基于浏览器的云服务。当我们着手开发Figma时，我们知道它将是个挑战。要真正取得成功，它必须提供专业人士愿意接受的高保真编辑体验以及在任何平台如出一辙的操作体验。</p><blockquote><p>要实现这一点真的很难。我们基本上最后是在浏览器上构建另一个浏览器。</p></blockquote><p>之所以很难，是因为Web并非被设计为通用计算平台。它最初是作为一种主要用于文档以及基于文档的应用程序开发的技术合集。Web这些技术通常使用针对一次性生效的特定API形式，而不是提供可用于实现各种事情的通用原语（C：可以理解为元素的原始数据）比如：</p><ul><li><p>CSS有很多<a href="http://www.w3.org/TR/css3-fonts/#font-rend-props">精美的文本布局算法，</a>但是无法自定义算法或读取浏览器的结果，因此文本布局算法可以用作其他算法的一部分。</p></li><li><p>所有的浏览器都提供了<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">高性能的</a> <a href="https://msdn.microsoft.com/en-us/library/jj680148(v=vs.85).aspx">GPU合成器，</a>但是Web上没有任何方法可以挂接到渲染算法上，也无法更改合成的方式来添加性能优化或自定义混合模式之类的东西</p></li><li><p>浏览器嵌入了<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=573948">高度优化的</a> <a href="https://code.google.com/p/chromium/issues/detail?id=48789">图像</a> <a href="http://blogs.msdn.com/b/ie/archive/2013/09/12/using-hardware-to-decode-and-load-jpg-images-up-to-45-faster-in-internet-explorer-11.aspx">解码器</a>，这些<a href="https://code.google.com/p/chromium/issues/detail?id=48789">图像</a><a href="http://blogs.msdn.com/b/ie/archive/2013/09/12/using-hardware-to-decode-and-load-jpg-images-up-to-45-faster-in-internet-explorer-11.aspx">解码器</a>使用最新的硬件功能从UI线程异步解码图像，但是没有API可以将参数传递给解码器以执行诸如<a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2014Apr/0064.html">处理EXIF方向</a>或避免使用drawImage和getImageData时<a href="https://code.google.com/p/chromium/issues/detail?id=425935#c8">在显示色彩空间中进行烘培</a>。</p></li></ul><p>Web上缺少通用原语的情况正在<a href="https://extensiblewebmanifesto.org/">开始改变</a>，现在有诸如WebGL和asm.js之类的技术可以使开发人员跳过浏览器并直接与硬件对话。正是这种进步最终使基于Web的高性能图形应用程序变得可实现。开发人员不再需要等待将其添加到Web的新标准，他们可以自己构建这些功能！</p><h2 id="Emscripten"><a href="#Emscripten" class="headerlink" title="Emscripten"></a>Emscripten</h2><p>我们的编辑器是用C ++编写的，并使用<a href="http://emscripten.org/">emscripten</a>交叉编译器交叉编译为JavaScript 。emscripten编译器针对asm.js 一个JavaScript子集，该子集提供了一种使JavaScript的JIT产生可预测的简洁机器代码的方法，并且在所有现代浏览器中均<a href="https://hacks.mozilla.org/2015/03/asm-speedups-everywhere/">得到广泛支持</a>。这具有以下好处：</p><ul><li>我们能完全控制内存布局，并且可以在适当时使用紧凑的32-bit float或64-bit double，而不是JavaScript的64-bit double。这对于像我们这样使用大量数据的应用程序非常重要。</li><li>生成的代码完全由分配控制，这可以避免GC带来的暂停，从而更轻松地达到60fps。所有C ++对象只是预分配类型数组中的保留范围，因此从不涉及JavaScript GC。</li><li>使用LLVM的高级优化器对生成的代码进行了预优化。这与C ++模板专业化相结合，可以生成非常有效的代码，该代码的<a href="https://hacks.mozilla.org/2014/05/asm-js-performance-improvements-in-the-latest-version-of-firefox-make-games-fly/">性能</a>是<a href="https://hacks.mozilla.org/2014/05/asm-js-performance-improvements-in-the-latest-version-of-firefox-make-games-fly/">本机性能</a>的<a href="https://hacks.mozilla.org/2014/05/asm-js-performance-improvements-in-the-latest-version-of-firefox-make-games-fly/">2</a>倍<a href="https://hacks.mozilla.org/2014/05/asm-js-performance-improvements-in-the-latest-version-of-firefox-make-games-fly/">或更高</a>。</li><li>确保所有asm.js代码都没有负优化点，因此JIT可以提前进行编译并提供可预测的性能。常规的JavaScript代码改为依赖JIT启发式，有时在同一代码的后续运行之间，性能有时会大相径庭。</li></ul><p>这并不是说emscripten是完美的。与任何新技术一样，开发之路上也有很多坎。对我们来说，一个大问题是某些浏览器配置无法为包含整个脚本存储空间的巨大类型数组分配大范围的连续地址空间。最坏的情况是<a href="https://code.google.com/p/chromium/issues/detail?id=394591">Windows上的32位Chrome</a>，有时甚至无法分配256mb类型的数组，因为<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>正在分割地址空间。此后已解决。（C：当时Chrome限制64位为1.4GB，32位为512MB）</p><p>一个有用的技巧是使用句柄为大量资源（如图像和几何缓冲区）使用堆外数据。我们有一个称为IndirectBuffer的内部API（我们在<a href="https://github.com/evanw/indirectbuffer">这里</a>开放源代码），该API引用一个外部类型的数组并将其提供给C ++。将大型分配移出主堆可减少长时间运行的会话的内存碎片问题，使我们能够在32位浏览器中使用更多有限的地址空间，并允许我们突破64<a href="https://github.com/WebKit/webkit/blob/f01d2bb66fcde2c3519c4f0c61f790387fd5faee/Source/JavaScriptCore/runtime/ArrayBuffer.h#L255">位中</a>的<a href="https://github.com/WebKit/webkit/blob/f01d2bb66fcde2c3519c4f0c61f790387fd5faee/Source/JavaScriptCore/runtime/ArrayBuffer.h#L255">31位类型化数组大小限制</a>位浏览器。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>我们已经实现了自己的渲染引擎，以确保内容能够在平台之间快速，一致地渲染。浏览器具有惊人的图形实现，我们最初尝试使用它们，而不是构建新的渲染引擎。如果没有低级API来访问浏览器的渲染树，则可用的选项是HTML，SVG或2D画布。这些选择都不令人满意，原因有很多：</p><ul><li>HTML和SVG包含很多负担，并且由于DOM访问，通常比2D canvas API要慢得多。这些通常是针对滚动而不是缩放进行优化的，并且每次缩放比例更改后，几何形状通常都会重新细分（C：Tessellation将很多高阶的图元变成很多小图元的过程）。</li><li>无法保证GPU的加速，并且许多东西仍在CPU上渲染，在某些情况下这可能会非常慢。</li><li>在HTML和SVG中，对遮罩，模糊和混合模式的支持在浏览器之间千差万别，在高DPI显示器上通常不抗锯齿或分辨率太低。</li><li>2D canvas API是立即模式API，而不是保留模式API，因此必须将每帧的所有几何图形重新上传到显卡。这是不必要的浪费，并且可能成为瓶颈。</li><li>文本布局<a href="https://css-tricks.com/font-rendering-differences-firefox-vs-ie-vs-safari/">在浏览器之间</a>是<a href="https://css-tricks.com/font-rendering-differences-firefox-vs-ie-vs-safari/">不一致的，</a>甚至<a href="http://blog.typekit.com/2010/10/21/type-rendering-web-browsers/">在不同平台上</a>的<a href="http://blog.typekit.com/2010/10/21/type-rendering-web-browsers/">同一浏览器</a>之间也是不一致的。</li><li>我们希望能够添加任何这些渲染API均不支持的功能，例如<a href="http://i.stack.imgur.com/ivV6l.png">角度渐变</a>。</li></ul><p>我们并没有试着使用HTML，SVG或者2D画布解决上面问题，而是使用WebGL从头开始实现了所有功能。我们的渲染器是高度优化的基于图块的引擎，支持遮罩，模糊，抖动渐变，混合模式，嵌套层不透明度等。所有渲染均在GPU上完成，并且完全抗锯齿。在内部，我们的代码看起来很像浏览器内部的浏览器；我们有自己的DOM，我们的合成器，我们自己的文本布局引擎，并且我们正在考虑添加一个渲染树，就像一个浏览器用来渲染HTML一样。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Web平台的功能一直在追赶原生平台，不幸的是目前仍然存在一些差距。尽管我们没有足够的资源来填补一些较大的空白，但我仍然会尽力解决可能的问题。</p><p>在开始使用Figma之前，高DPI自定义光标在Web上确实被broken了。我必须手动修复<a href="https://code.google.com/p/chromium/issues/detail?id=268537">Chrome</a>，<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=888689">Firefox</a>和<a href="https://bugs.webkit.org/show_bug.cgi?id=120783">WebKit，</a>因为它们都以不同的方式broken。仍然没有统一的方法（Firefox使用SVG，Chrome浏览器和WebKit使用-webkit-image-set以及IE使用古老的.cur格式），但至少现在有可能。</p><p>我还修复了一些<a href="https://bugs.webkit.org/show_bug.cgi?id=97237">严重的</a> <a href="https://bugs.chromium.org/p/angleproject/issues/detail?id=415">性能</a>和<a href="https://code.google.com/p/chromium/issues/detail?id=239731">可用性</a>错误，以使我们的产品更好。有时，Web可能令人沮丧，但是浏览器并不是黑匣子（嗯，除了<em>那个</em>浏览器）。通常，解决烦人的Web问题需要泡在浏览器代码一整个下午，或者在一个patch上折腾一天，然后需要等待几个月才发布。</p><p>Web平台还有更多的潜力可以使Figma变得更好：</p><ul><li>我们最大的难点是缺乏进入字形轮廓和字距调整表，其中有目前<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=21939">没有任何方法</a> <a href="http://www.w3.org/TR/2dcontext2/#textmetrics">在得到的</a>。最主要的问题之一就是字体指纹识别（C：<a href="https://webbrowsertools.com/font-fingerprint/">字体指纹概念</a>），但是那场战斗<a href="http://discourse.wicg.io/t/api-to-get-list-of-available-fonts/1197">已经失败了</a>。我们希望可以像其他隐私敏感型API一样，在用户权限提示后公开对字体数据的访问。Chrome浏览器<a href="https://github.com/DHNishi/LocalFontAccess/blob/master/explainer.md">提出</a>了一个正在开发<a href="https://code.google.com/p/chromium/issues/detail?id=535764">中的</a>修复程序<a href="https://github.com/DHNishi/LocalFontAccess/blob/master/explainer.md">提案</a>（它们确实很有帮助！），但是其他浏览器没有其他的可预见性了。</li><li>我们很想增加对常见剪贴板格式（.ai，.pdf等）的支持，但是Web上<a href="https://github.com/w3c/clipboard-apis/issues/9#issuecomment-159023296">却没有办法做到这一点</a>。规范中唯一的格式是text &#x2F; plain和text &#x2F; html（我们的Figma剪贴板“格式”是text &#x2F; html，二进制数据编码为HTML注释）。</li><li>我们面临的另一个问题是缺乏对OS X触控板捏合手势的支持。Chrome浏览器添加了一个<a href="https://code.google.com/p/chromium/issues/detail?id=289887">鲜为人知的技巧</a>，其中捏手势使用ctrlKey向下发送wheel事件，并调用preventDefault（）允许页面对其进行处理。这真是太神奇了，它使Figma的缩放和平移变得自然而轻松。我试图<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1052253">将其添加到Firefox中，</a>但该尝试目前仍停留。在Safari中进行捏合会导致缩放行为，这确实使用户感到困惑，并且<a href="https://bugs.webkit.org/show_bug.cgi?id=145214">无法禁用</a>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>性能和质量是我们最重要的功能。它们与正常功能有所不同，因为您只会在不存在它们时才注意到它们，但它们却与众不同。</p><p>我很高兴终于向世界展示Figma。该产品尚未向公众开放，但您可以<a href="https://www.figma.com/">注册</a>我们的候补名单并尽快试用。让我们知道您的想法！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;译-在Web上构建专业的设计工具&quot;&gt;&lt;a href=&quot;#译-在Web上构建专业的设计工具&quot; class=&quot;headerlink&quot; title=&quot;[译]在Web上构建专业的设计工具&quot;&gt;&lt;/a&gt;[译]在Web上构建专业的设计工具&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    
    <category term="浏览器" scheme="https://nick22nd.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="Figma" scheme="https://nick22nd.me/tags/Figma/"/>
    
    <category term="翻译" scheme="https://nick22nd.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="设计工具" scheme="https://nick22nd.me/tags/%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Web" scheme="https://nick22nd.me/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>React Native, Flutter的使用记录</title>
    <link href="https://nick22nd.me/posts/RN-Flutter-SwiftUI/"/>
    <id>https://nick22nd.me/posts/RN-Flutter-SwiftUI/</id>
    <published>2020-12-10T01:13:59.000Z</published>
    <updated>2024-05-27T11:00:34.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是博主作为一名<strong>前端</strong>对RN，Flutter和SwiftUI轻度使用的感受，以及学习过程中碰到的一些问题和解决办法。因为之前并没有接触过原生开发，所以可能存在很初级的问题，或者用笨拙的方法解决了问题，或者内容有错误，有读者发现明显错误的，欢迎评论区指出。<br>（组件，控件，widget）</p><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><p>首先是<a href="https://reactnative.dev/">React Native</a>，’Learn once, write anywhere’. 对于前端而言最为亲切的跨端框架，JSX + 弱化版的CSS能够像前端开发一样直接书写移动端应用。</p><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>基本原理如图</p><p><img src="/images/RN-Arch.png" alt="RN-Arch"></p><p>React的虚拟dom出口：</p><ol><li>web中的document对象，通过浏览器完成渲染（渲染引擎Webkit&#x2F;Gecko）。</li><li>以Bridge作为通信中介的原生组件映射，在原生平台渲染。</li></ol><p>第二点这也是Native的名称含义-原生渲染。关键点在于<strong>虚拟DOM和原生组件中的DSL的实现</strong>。如何抽象出不同平台的原生组件的公共部分封装成组件库？然后虚拟DOM如何按照预期地影响原生组件？这中间的适配迭代过程中的开发问题，看过去几年的RN话题的讨论记录和github中总共<a href="https://github.com/facebook/react-native">2w的issues数量</a>和Airbnb放弃RN时发的<a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">5篇记录Airbnb使用记录</a>，可见一斑。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>用RN写普通页面和前端开发并没有太大的区别， 只不过从浏览器的DOM标签变成了RN封装的基础组件。需要根据样式和业务逻辑切分和复用组件。</p><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><ul><li>支持Fetch，可以用Promise自行封装.</li><li>支持AJAX, 所以封装AJAX的第三方库比如axios也能使用.</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>KV存储也有官网的AsyncStorage</p><h4 id="原生联系"><a href="#原生联系" class="headerlink" title="原生联系"></a>原生联系</h4><p>React Native 可以通过原生模块的方式来通过Bridge异步地和原生代码进行通信。RN中很多库都十分依赖原生，毕竟本身就是对原生的抽象，所以React Native与原生开发密不可分，采用RN大概率需要混合开发。</p><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p><a href="https://flutter.dev/">Flutter</a>近两年热度最高的跨端技术（issues一直增加）。</p><h3 id="原理简介-1"><a href="#原理简介-1" class="headerlink" title="原理简介"></a>原理简介</h3><p>它采取的方法是将Dart编译成原生系统的可执行程序，控制应用的每一个像素，用Skia绘制并渲染UI，并添加相应的交互逻辑构成部件–Flutter这里是叫Widget。因为<strong>部件的渲染和逻辑都是Flutter来完成</strong>，所以Flutter能够保障不同平台，不同设备UI的一致性。并且本身就提供了Material 和Cupertino两套类原生风格的控件实现，也能保障原生UI的使用体验。当前已经支持Android、iOS、Windows、Linux、Web。<br>基本架构如图<br><img src="/images/archdiagram.png" alt="Arch Diagram"></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>Flutter的很多地方都和React类似, 都是状态更新setState(), 然后触发UI更新.<br>常用的UI相关的Widget有两种</p><ol><li>StatelessWidget: 不维护State</li><li>StatefulWidget: 通过createState创建State, 在State类中通过setState((){ statement })更新状态.</li></ol><h5 id="网络请求-1"><a href="#网络请求-1" class="headerlink" title="网络请求"></a>网络请求</h5><p>Dart IO库中可以创建HTTP请求</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">HttpClientRequest request = <span class="keyword">await</span> httpClient.getUrl(uri);</span><br></pre></td></tr></table></figure><p>另外有非常优秀的第三方开源网络库DIO, 可以省下自己造轮子的时间.<br>但是作为JavaScript使用者, 注意Dart处理JSON文件不能像直接转换成对象. 这里最好是约定好数据格式, 类似ORM的思路创建对应的Model类, 写好转换逻辑. </p><h4 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h4><p>KV存储有shared_preferences, Android和iOS都能够适配, 使用也较为简单就不赘述, 具体直接看<a href="https://pub.dev/packages/shared_preferences">文档</a></p><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><p>Flutter这里思路与RN的处理也是非常类似, 对应ReactNative中的useContext, Flutter中有专门的状态共享部件InheritedWidget 能够自上而下的数据共享. 在根Widget中使用InheritedWidget共享状态, 其它Widget都能通过获取该状态. 这里可以使用基于InheritedWidget封装的库Provider来直接使用封装好订阅发布的功能. </p><p>结合Redux状态容器辅助理解, 其实也是Elm的架构逻辑.</p><h2 id="主观的感受"><a href="#主观的感受" class="headerlink" title="主观的感受"></a>主观的感受</h2><ol><li>在书写体验上，RN使用TSX既能快速开发出页面，又能享受TypeScript的保障，单单就写UI而言能保持和前端基本一致的体验。而Flutter的Dart开发过程中的层层嵌套，真的是很让人崩溃，真希望能赶紧出个DTX（据说有提议）。</li><li>在生态上，RN先出来这么久，各种问题和需求都能找到经验参考，而Flutter还处于快速发展，看看8k的open issues，意味着它还有很长的路要走。</li><li>从技术吸引力来说，Flutter完全掌握渲染部分显然更加吸引人，类似游戏引擎的结构，理论上可以自己添加新的一套UI+逻辑，就像弱化版的浏览器一样。RN就期待着新架构能早点使用起来。</li><li>React Native真的需要对原生开发有所掌握，这方面还需要继续加油。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://flutter.cn/docs/resources/inside-flutter">Flutter 工作原理</a></p><p><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html">Flutter原理与实践</a></p><p><a href="https://tech.meituan.com/2020/09/30/waimai-mobile-architecture-evolution.html">外卖客户端容器化架构的演进</a></p><p><a href="https://tech.meituan.com/2019/12/19/meituan-mrn-practice.html">React Native在美团外卖客户端的实践</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是博主作为一名&lt;strong&gt;前端&lt;/strong&gt;对RN，Flutter和SwiftUI轻度使用的感受，以及学习过程中碰到的一些问题和</summary>
      
    
    
    
    
    <category term="React Native" scheme="https://nick22nd.me/tags/React-Native/"/>
    
    <category term="Flutter" scheme="https://nick22nd.me/tags/Flutter/"/>
    
    <category term="SwiftUI" scheme="https://nick22nd.me/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>Rails初入的环境问题</title>
    <link href="https://nick22nd.me/posts/rails-env-in-china/"/>
    <id>https://nick22nd.me/posts/rails-env-in-china/</id>
    <published>2020-11-11T07:09:24.000Z</published>
    <updated>2024-06-02T11:07:54.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主是从RubyConf China 2020开始前一天才开始写Ruby的Hello World. 在了解了<a href="http://www.rubyconfchina.org/">Ruby各种应用和社区发展</a>以后(这个以后有空再补充) , 觉得很有趣, 自然工作之余开始了Ruby和Rails的学习. </p><p><strong>参照</strong><a href="https://ruby-china.org/wiki/install_ruby_guide">Ruby China</a>中的入门教程开始配置环境, 期间也遇到过不少的问题. 有些问题是新手角度特有的, 有些问题是Rails更新结合国内特有的网络环境后新引入. 本来只是自己记录的笔记, 但后来在群聊中多次见到相关的问题, 所以发出来希望能给碰到相同问题的朋友一些参考吧.</p><h2 id="gem源问题"><a href="#gem源问题" class="headerlink" title="gem源问题"></a>gem源问题</h2><p>报错类似以下形式:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>While executing gem ... (Gem::RemoteFetcher::UnknownHostError)</span><br><span class="line">    timed out (https://api.rubygems.org/latest_specs.4.8.gz)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR: </span>Could not find a valid gem &#x27;rails&#x27; (&gt;= 0), here is why:</span><br><span class="line">          Unable to download data from https://rubygems.org/ - timed out (https://api.rubygems.org/specs.4.8.gz)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因:"></a>可能的原因:</h3><ol><li>本机的DNS无法获得rubygems.org的IP地址<br>修改本机的DNS, 确保能正常获取到地址, 可以通过curl&#x2F;wget下载文件来测试问题是否解决.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.rubygems.org/specs.4.8.gz &gt; specs.4.8.gz </span><br></pre></td></tr></table></figure>稳妥的方法是切换到ruby china的国内源(注意taobao的源已经不再维护, 而且<strong>ruby-china后缀是com</strong>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></li><li>SSL问题, 这个需要更新相关的证书</li><li>Debian系统<br>如果<ol><li>切换源的命令执行后, 依然无法正常切换 &amp;&amp;</li><li>或者直接修改~&#x2F;.gemrc文件切换后 &amp;&amp;</li><li>curl命令可以正常下载文件specs.4.8.gz &amp;&amp;</li><li>继续提示ERROR: While executing gem … (Gem::RemoteFetcher::UnknownHostError)timed out</li></ol></li></ol><p>那可能是Debian系统存在的问题, 如IPV6的设置, 可以参考如下信息</p><ul><li><a href="https://stackoverflow.com/questions/49800432">StackOverflow相关问题gem cannot access rubygems.org</a></li><li><a href="https://help.rubygems.org/discussions/problems/31074-timeout-error">rubygems的help版块</a></li></ul><p>注: 博主是WSL2的Debian64bit的系统, 就碰到了原因3, 所以就直接换了Ubuntu, 按照教程重新安装, 所以并没有实际解决该问题.</p><h2 id="Rails中Webpack相关的问题"><a href="#Rails中Webpack相关的问题" class="headerlink" title="Rails中Webpack相关的问题"></a>Rails中Webpack相关的问题</h2><p>由于Rails在创建新项目时默认使用Webpack, 所以会有很多Node模块需要在新建过程中安装. 而npm官方的源同样会在国内的网络环境下, 下载安装过程会有各式各样的问题.<br>所以首先设置国内的npm镜像源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>理论而言, 应该能rails new sample能正常创建项目了, 但是即便npm设置了taobao的镜像, 有很大的可能会在npm下载安装依赖包的时候卡住. 最为典型的就是卡在node-sass.</p><p>先说解决方案:<br>还需要特别设置sass的binding.node的下载地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">npm config <span class="built_in">ls</span> -l             // 查看配置信息, 可以检查下前面两步npm配置是否设置成功</span><br></pre></td></tr></table></figure><h3 id="具体的原因说明以及排查的过程"><a href="#具体的原因说明以及排查的过程" class="headerlink" title="具体的原因说明以及排查的过程"></a>具体的原因说明以及排查的过程</h3><p>node-sass的问题也是坑过了无数前端, 首先它是编译Sass到css库libSass的node绑定, 使用非常广泛, 当前(2020.11.11)原项目团队已经转到dart-sass的开发, node-sass以后应该慢慢会弃用了, 它的安装过程具体分析可以<a href="https://segmentfault.com/a/1190000020993365">参考此篇</a></p><p>它导致rails出现的问题如下:</p><ol><li>在国内网络情况下, rails创建新项目过程中node-sass中的脚本无法正常拉取github中的文件, 导致需要本地长时间的building(需要python2等一系列依赖), 最后安装失败, 它虽然会报错, 但是也有可能并不会停下, 其它流程都一切正常.</li><li>流程走完, rails new执行报错: Error: Cannot find module ‘@rails&#x2F;webpacker’, 之前安装未完成造成的;找不到webpack的命令.</li></ol><p>另外只会在安装过程提示building node-sass以及失败信息, 但是如果你Ctrl+C 取消安装, 然后再重新安装. npm可能会由于node_module&#x2F;node-sass的文件夹中已经存在相关文件, 以为已经安装成功而略过node-sass. 导致后续出错信息由于webpacker对webpack的封装, 并不再提示node-sass的错误信, 只会提示webpack出错.</p><p>node-sass由于TF-GFW的原因导致无法正常安装, 导致webpack安装出错, 导致webpacker出错, 导致新加Controller后无法被webpacker编译到public&#x2F;packs中, 于是可能会出现如下错误:</p><ol><li>manifest为空的报错 </li><li>webpack命令找不到 : (error Command “webpack” not found.) </li><li>webpack安装: yarn add webpack, 继续调试又会报错( Error: Cannot find module ‘webpack-cli’ ),并建议你安装webpack-cli ;</li><li>webpack-cli安装: yarn add -D webpack-cli, 继续调试又会报错( Error: Cannot find module ‘@rails&#x2F;webpacker’ );<br>@rails&#x2F;webpacker &gt; node-sass &gt; <a href="mailto:&#x72;&#x65;&#x71;&#x75;&#101;&#115;&#x74;&#x40;&#50;&#46;&#56;&#x38;&#x2e;&#x32;">&#x72;&#x65;&#x71;&#x75;&#101;&#115;&#x74;&#x40;&#50;&#46;&#56;&#x38;&#x2e;&#x32;</a>: request has been deprecated</li></ol><p>最后不得不吐槽, 这网络环境<strong>简直是在消磨技术热情</strong>, 尤其是各种工具,语言初学阶段, 如Docker, Gradle, Android. 熟手或许能轻而易举地发现并解决, 但是新手刚开始感兴趣去接触, 希望按照官网的教程开始新的旅程, 结果迎面就是一堵高墙, 墙面写着:</p><blockquote><p>“Across the Great Wall, we can reach every corner in the world”.  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;博主是从RubyConf China 2020开始前一天才开始写Ruby的Hello World. 在了解了&lt;a href=&quot;http://</summary>
      
    
    
    
    <category term="技术" scheme="https://nick22nd.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Ruby" scheme="https://nick22nd.me/tags/Ruby/"/>
    
    <category term="Rails" scheme="https://nick22nd.me/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JS（上）</title>
    <link href="https://nick22nd.me/posts/you-dont-know-JS/"/>
    <id>https://nick22nd.me/posts/you-dont-know-JS/</id>
    <published>2020-08-07T13:20:19.000Z</published>
    <updated>2024-05-27T11:00:34.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1 作用域"></a>1 作用域</h2><ul><li>referenceERROR， 会在strict模式下，LHS查询全局作用域不能找到抛出，非严格模式下则会创建； 还有在RHS查询一个未声明的变量时</li><li>RHS查询完成后，如果对其进行不合理操作，那么就会报typeError错误（比如非函数类型做函数调用，引用null或者undefine值中的属性）c:果然是有静态分析的</li></ul><h2 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2 词法作用域"></a>2 词法作用域</h2><h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h3><ul><li>查找，不知道vuex的store中的命名空间是怎样的实现？</li></ul><h3 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a>2.2 欺骗词法</h3><ul><li>这eval()不是方便XSS吗…..</li><li>with，非严格模式下，如果没有在自己特定作用域，所处函数作用域，全局作用域LHS都没找到，然后就自己创建了一个全局变量</li></ul><h2 id="3-函数作用域与块作用域"><a href="#3-函数作用域与块作用域" class="headerlink" title="3 函数作用域与块作用域"></a>3 函数作用域与块作用域</h2><ol><li><p>隐藏内部实现</p></li><li><p>函数作用域function和(function有着不同的作用， 后者作为函数表达式， 不需要显式地调用函数名。</p></li><li><p>匿名与具名</p><ol><li>前者可以等同于具名函数表达式命名</li></ol></li><li><p>立即执行函数表达式</p><ol><li>IIFE</li><li>两种写法(function(){}) (), (function(){}())</li></ol></li></ol><h2 id="4-提升"><a href="#4-提升" class="headerlink" title="4 提升"></a>4 提升</h2><ol><li>变量和函数的声明会被提前， 而赋值和逻辑运算则会停在原地， 有时候会出现奇怪的错误； 函数提升优先级更高</li></ol><h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5 闭包"></a>5 闭包</h2><p>定义： 函数， 在定义时的语法作用域以外的地方被调用； 访问定义时的词法作用域<br>闭包域作用域， 例子非常有意思； var， let<br>模块模式的两个必要条件：</p><ol><li>必须有外部的封闭函数， 函数必须被调用一次（每次调用会产生新的实例</li><li>封闭函数必须返回至少一个内部函数，形成闭包并提供状态的作用接口</li></ol><p>单例模式，IIFE即可完成；<br>命名公共API返回的对象<br>感觉和Java的类，实例，匿名类一个机制</p><h2 id="1-关于this"><a href="#1-关于this" class="headerlink" title="1 关于this"></a>1 关于this</h2><ol><li>不是调用自身而是调用</li></ol><h2 id="2-this全面解析"><a href="#2-this全面解析" class="headerlink" title="2 this全面解析"></a>2 this全面解析</h2><p>从调用位置来理解</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><ol><li><p>默认绑定</p><ul><li>默认绑定，严格模式下会无法绑定到全局变量中</li></ul></li><li><p>隐式绑定</p><ul><li>自适应绑定，类似同名变量在作用域中的覆盖；这里this绑定也会随着调用位置的被覆盖</li><li>参数赋值是一种隐性赋值，传入对象.函数,仅仅是传入函数，相当于是默认绑定</li></ul></li><li><p>显式绑定</p><ul><li>call（其实现会通过强制转换为对象，this绑定到obj中）</li><li>apply</li><li>API调用上下文：通过添加一个参数来增加一个绑定对象（本质同call和apply）</li></ul></li><li><p>new绑定</p><ol><li>不存在构造函数，只有对函数的“构造调用”</li></ol></li><li><p>优先级</p><ol><li>bind()的实现，会先检测是否被new调用？替换掉旧的硬绑定：维持不可修改的特性；为什么？因为需要传递调用时添加的参数给下层函数。</li></ol></li><li><p>例外</p><ol><li>apply(null,[2,3])为了传递参数，null会默认</li><li>柯里化</li><li>创建DMZ对象，创建空对象作为this的空间；Object.create(null)</li><li>间接引用，默认绑定</li><li>软绑定，给内置bind包装了成了自适应类似DMZ的方法</li></ol></li><li><p>this</p><ol><li>箭头函数会从函数作用域寻找，this的绑定</li><li>作用域和箭头函数， 和传统的this机制</li></ol></li></ol><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3 对象"></a>3 对象</h2><ol><li><p>type</p><ol><li>object type</li></ol></li><li><p>属性和方法</p><ol><li>函数永远不会“属于”一个对象； 虽然有些会有this绑定，但这是另一回事</li></ol></li><li><p>数组：数值下标&#x2F;值对</p></li><li><p>对象复制，c：vue-admin-template中有deepClone是通过键值对的拷贝，const；</p><ol><li>翻译有失误，浅拷贝，深复制</li><li>浅拷贝的assign：将enumerable自有键复制到目标对象，使用&#x3D;赋值</li></ol></li><li><p>属性描述符： 所有属性都具备了属性描述符</p></li><li><p>不变性：</p><ol><li>对象常量</li><li>禁止扩展</li><li>seal：调用2并，设置configable：false；</li><li>freeze：调用3并设置writable：false；大概是最高级别的不可变，引用的对象可以遍历引用对象，全部freeze</li></ol></li><li><p>get 一个undefined确实够有趣的；put应用依然不太明白；（名称：_a_只是命名惯例）</p></li><li><p>存在性：in和hasproperty区；in是<strong>属性</strong>是否存在对象极其原型链（c：in的多义颇有*在c中的1&#x2F;100风采）</p></li><li><p>Symbol.iterator 与内置的@@iterator（一个迭代器函数对象的汉顺），for of 的本质和改写；</p></li><li><p>为什么永不结束就会挂起</p></li></ol><h2 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h2><p> 类也只是一种基础设计模式<br> JS只是模拟类的<br> C：编程和建筑非常像….似乎的确如此</p><p> 这里的多态解释：继承链中不同层次的一个方法名被多次定义，调用方法时会自动选择合适的定义</p><p> JS中类与构造函数，与真正的类有所不同</p><p> 方法继承和重写（多态）取决于你在哪个类的实例中使用；重写不会影响到父类，子类只是一个副本；继承的本质是复制。</p><p> 多重继承…..好吧我对面向对象实在很不熟悉。</p><p> **JS中只有对象，通过关联来连接 **。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol><li>通过call来将this绑定当前context，实现<strong>显式的多态</strong></li><li>先复制，再进行特殊化覆盖….c:真是朴素的方法.  函数的引用问题怎么解决呢？共享一个函数</li><li>寄生继承：完全没明白</li></ol><p>复制对象引用，而不能复制对象本身</p><h2 id="5-原型链"><a href="#5-原型链" class="headerlink" title="5 原型链"></a>5 原型链</h2><ol><li>Object.prototype原型链的最终节点</li><li>底层会覆盖上层的同名，选择最近，</li></ol><p>只存在上层prototype的三种情况：</p><ol><li>默认，直接添加到当前对象，屏蔽属性</li><li>writable:false ，strict 会报错，非~会被忽略（禁用父类的属性“继承”，但是可以通过defineProperty</li><li>上层存在且有setter，那么会调用setter</li></ol><p>隐式屏蔽，obj.a++    &#x3D;&#x3D;&gt; obj.a &#x3D; obj.a + 1 会调用[[put]] </p><h3 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h3><ol><li>调用new Foo()创建 的每个对象将最终被[[prototype]]链接到<strong>Foo.prototype对象</strong>；并非直接关联到对象，而是通过关联到其他对象的新对象</li><li>原型继承（c:容易造成语义上的误解）</li><li>继承no &#x3D;&gt; 通过委托访问属性和函数</li><li>new 的机制很有意思，即便new一个普通函数，也会出现构造函数的效果，或者说new 时，函数调用会变成构造函数调用</li><li>所以constructor只是属性名，空白对象没有（可以自己定义），最终会沿着prototype到Object中</li><li>这里直接通过Object.create(obj.prototype)新建对象来关联期待的对象……这个真的很奇怪<ol><li>两种错误示范写法：Bar.prototype &#x3D; Foo.prototype 直接引用了Foo，任何修改都会同步到Foo</li><li>Bar.prototype &#x3D; new Foo()  new作为构造函数的触发关键词，会有造成构造函数的副作用</li></ol></li><li>ES6可以直接修改prototype   –  Object.setPrototypeOf( source.prototype, target.prototype)</li><li>检查实例的继承祖先（内省、反射）；  isPrototypeOf  ES5： <strong>proto</strong> 的奇怪属性（应该是getter+setter</li></ol><h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><ol><li>Object.create(null)对象无法进行委托，instance of 检测不到原型链</li></ol><h2 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h2><blockquote><p>原型链的本质就是对象之间的关联关系</p></blockquote><p>OLOO</p><ol><li>最好将状态保存到委托者，而不是委托目标</li><li>避免同名函数，不是面向对象重写</li><li>在本身找不到时会使用委托</li></ol><p>的确在理解了JS的原型链机制后，再用它来写java风格，就很奇怪….</p><p>两张图就很清晰了</p><p>C: 其实这种语言特性在业务开发中，表面上不懂也没事，常用的框架将关注点集中到了解决问题上，只需要按照需求填入内容即可，做出的能用，但是一旦出现性能瓶颈，框架考虑范围外的事情（这里其实涉及到泛用性和专用，自由度等的取舍博弈），这时候就会有对底层原理（相对问题而言）理解有所要求。经验和原理同样重要，两者都需要花费时间成本，大量的练习，才能相互印证真正理解why。</p><p>C:DRY其实也包含工作内容，当融会贯通，然后继续重复就毫无意义（边际成本）</p><p>蓝图设计（设计文档）果真就能反应设计的好坏，最起码清晰，层次分明</p><ol><li>类语法糖，让JS看起来真像那么回事儿；但还是有之前的问题，只是语法上更加友好了</li><li>委托轻松了很多，但是命名该怎么解决呢？每一次都换名吗？</li></ol><p>构造和初始化分离</p><p>两种风格的比较：委托更像是灵活的组合</p><p>ES6更好的语法：</p><ol><li>class减少使用’,’,简洁声明方法减少function</li><li>可以轻便地关联对象–setPrototypeOf()</li><li>简洁方法的副作用，默认返回匿名函数<ol><li>没太明白匿名函数递归是怎么回事?</li></ol></li></ol><p> instanceof 内省， 它的<strong>表面含义与实际语言机制的不同</strong>，尽管结果是符合表面含义</p><p> 鸭子类型，JS真是欢乐之源； Promise</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>通过extend，扩展了对象类型</li><li>class中只能声明方法，减少了犯错的可能</li><li>构造函数问题解决</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>本质上仍然是prototype的一种语法糖，是实时的委托而不是复制</li><li>共享和私有的实现</li><li>同名属性和方法的屏蔽</li><li>super中的this的动态绑定</li><li>toMethods方法绑定到原方法</li></ol><p>class真是个大坑….而且真是别扭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-作用域&quot;&gt;&lt;a href=&quot;#1-作用域&quot; class=&quot;headerlink&quot; title=&quot;1 作用域&quot;&gt;&lt;/a&gt;1 作用域&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;referenceERROR， 会在strict模式下，LHS查询全局作用域不能找到抛出，非严格模式下则</summary>
      
    
    
    
    
    <category term="JS" scheme="https://nick22nd.me/tags/JS/"/>
    
    <category term="读书笔记" scheme="https://nick22nd.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>浏览器上音视频的播放和传输</title>
    <link href="https://nick22nd.me/posts/audio-video-playback-and-transmission-on-the-browser/"/>
    <id>https://nick22nd.me/posts/audio-video-playback-and-transmission-on-the-browser/</id>
    <published>2020-07-20T03:30:52.000Z</published>
    <updated>2024-05-27T11:00:34.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>音视频成为传输信息的重要媒介，而浏览器作为各平台最为泛用的软件，本文对音视频的在浏览器上的播放和传输进行简单说明。</p><p>PC 上因为客户端播放音视频过于沉重，需要单独下载播放器，而B&#x2F;S 结构更加灵活，轻巧，便于新功能的集成，只需浏览器即可, 并且依托Web 具备跨平台的属性，并且方便接入其它的功能接口，且无需更新客户端。</p><h3 id="音视频在浏览器中的播放"><a href="#音视频在浏览器中的播放" class="headerlink" title="音视频在浏览器中的播放"></a>音视频在浏览器中的播放</h3><p>首先需要对多媒体有一些基本的概念，将目的作为理解的关键：</p><ol><li>容器格式<br>包括MP4，FLV，MKV等，其作用是将编码后的多媒体 “包装” 成一个文件，目的是<strong>方便播放</strong>。比如将不同的字幕和配音封装到一个MKV容器中，那么不同观众在观看时可以选择自己想要的字幕和配音种类，获得更好的体验。</li><li>编码格式<br>包括H.264, VP8，AAC等, 其作用是将原始的多媒体数据按照一定的算法进行编码，目的是<strong>压缩数据</strong>。比如一个影片中连续的两帧，都是满月当空，后一帧只是多了一个狼人，那么后一帧的信息只需要增加狼人部分的RGB点阵信息（并非实际算法）</li><li>传输协议<br>包括RTSP，RTMP，HLS等 ，是客户端和服务端传输媒体流的网络应用协议， 目的是<strong>传输</strong>。比如直播的过程主播通过采集媒体信息，通过推流传输到直播平台，直播平台处理流，观众进入直播间向服务器拉流，推拉流过程中都依赖传输协议。</li></ol><p>在浏览器中有以下三种方法来播放音视频</p><h4 id="ActiveX控件"><a href="#ActiveX控件" class="headerlink" title="ActiveX控件"></a>ActiveX控件</h4><p>来自微软的Basic，需要单独安装控件，浏览器只是提供窗口的功能；不过现在Chrome 和FireFox 都已经不再支持，只有IE 还提供支持。这种方案应用当前已经比较少了，在监控安防领域还有着部分的应用，因为使用的多为rtsp 协议的原因，这一协议在浏览器上基本没有合适的解决方案，要么使用单独的客户端如：VLC 播放器，要么采用IE+ActiveX 控件的形式来完成播放。</p><h4 id="Flash播放器"><a href="#Flash播放器" class="headerlink" title="Flash播放器"></a>Flash播放器</h4><p>来自Adobe 的flash，曾经使用最多最广泛，现在提及更多的是来自安全漏洞的源头，恨不得赶紧扫进历史的垃圾堆。Chrome 在Chrome 76 开始已经默认禁止，并且宣布2020 年12 月之后已经不再支持Flash 播放器。连Adobe 本身也宣布在2021 年起停止支持Flash。浏览器播放RTMP 流需要依赖Flash。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签&lt;video&gt;"></a>标签&lt;video&gt;</h4><p>Chrome 的媒体播放与架构中的Media 模块密切相关，支持的格式avc&#x2F;aac，avc也就是h264, google 自家的vp8,vp9, 具体情况可以看具体说明 <a href="https://sites.google.com/a/chromium.org/dev/audio-video">Chromium Project</a>。但是标准的HTML 中的&lt;video&gt;标签只支持MP4，而且还是fMP4(Fragment MP4)，总之&lt;video&gt; 对格式支持非常有限。而且&lt;video&gt;标签的src还不支持切换片段，而媒体流传输通常都会进行分片。如何解决这个问题？</p><p>解决的核心就是MSE(Media Source Extensions), 它的功能可以抽象成Media Source的两个方向：</p><ol><li>入口： 是Video 和Audio 的两个Buffer，传过来的媒体文件解析分离（demux）出视频流和音频流，然后放入两个Buffer中。</li><li>出口： Media Source 将音视频的两个Buffer重新封装（remux）fMP4格式的文件，通过<strong><strong>Blob对象和URL</strong></strong>，传出到&lt;video&gt;进行播放</li></ol><p>核心的两点：</p><ul><li>Media Source Extensions</li><li>Source Buffer</li></ul><p>这也是当前主流的播放方式，非常知名的开源项目flv.js<a href="https://github.com/xqq">来自谦谦大佬</a>就是通过JS软解flv，得到音视频流喂给MSE 的两个Buffer，最后生成fMP4文件交给&lt;video&gt;播放。</p><p>还有HLS（后文会有介绍）的在浏览器中的播放部分，只不过格式换成了ts的容器格式，而且增加m3u8格式作为一段媒体流的基本信息和索引列表。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>ActiveX几乎已经历史遗留产物了，也只有IE这样的兼容支持才能保持存在。</li><li>Flash即将在2020年12月不再支持，是Adobe公司本身宣布，浏览器将来也将停止支持；非常奇葩的是在中国，某司宣布会继续提供Flash支持。</li><li>浏览器上的音视频播放以后会全部通过 &lt;video&gt; 标签本身来实现。</li></ol><h3 id="音视频在浏览器中的传输"><a href="#音视频在浏览器中的传输" class="headerlink" title="音视频在浏览器中的传输"></a>音视频在浏览器中的传输</h3><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>HTTP传输通用性最强，不受到端口和防火墙的限制，最为典型的就是HLS（HTTP Live Streaming） 就是基于HTTP来实现的，相当于将需要传输的媒体文件，切分成带编号的媒体文件，然后通过HTTP协议来获取媒体文件，并且提供了一个媒体文件信息的列表，只需要按照列表顺序逐个拉取播放。</p><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><p>相较http而言，当前使用得比较少，但是也有ws-flv等方案，基本原理就是传输协议的变化，变成了对浏览器友好的websocket，对前端而言只是数据的获取从XHR 传输换成了websocket 而已。</p><h4 id="webrtc"><a href="#webrtc" class="headerlink" title="webrtc"></a>webrtc</h4><p>Chrome推出的新协议，在浏览器中有着原生的支持，主要用于P2P连接，主要的API</p><ol><li>getUserMedia: 从源（如网络摄像头）中获取音频和视频（注：在非HTTPS环境中会被禁止）</li><li>RTCPeerConnection: 音视频流的连接</li><li>RTCDataChannel: 音视频流的数据通道</li><li>MediaRecorder: 保存媒体流接口</li></ol><p>它是直接在传输层采用了RTP&#x2F;RTCP。RTP 本身就定义了要传输串流媒体的参数标准(封包标准)，或者说本质上就是一种流容器，所以不需要做太多处理即可播放，从这点而言更像是应用层。另外它虽然是传输层协议，但是又能基于TCP，UDP实现不同的传输。RTCP 则是为RTP 提供统计功能，描述传输状态。</p><p>另外P2P音视频的传输不能没有连接目标凭空传输，而P2P的坑点就在于如何在重重NAT+防火墙下建立双方的连接 ，webRTC在建立P2P连接的过程中会需要借助一个Signal Server（信令服务器搭建简单，并且有不少免费公开信令服务器可供选择），专门用于双方的交换信息，建立连接。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li>HTTP无需多言</li><li>websocket 与传统意义上的socket编程原理相似，借助HTTP来完成初次握手，在Header中会有upgrade的标记</li><li>WebRTC是一个很复杂的协议，底层是C&#x2F;C++实现的，在浏览器中提供JS的接口；浏览器只能使用设计好的接口，而在客户端中由于能直接修改C&#x2F;C++来适应业务需要，所以反而比浏览器应用灵活</li></ol><p>END</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;音视频成为传输信息的重要媒介，而浏览器作为各平台最为泛用的软件，本文对音视频的在浏览器上的播放和传输进行简单说明。&lt;/p&gt;
&lt;p&gt;PC 上因</summary>
      
    
    
    
    
    <category term="音视频" scheme="https://nick22nd.me/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="webrtc" scheme="https://nick22nd.me/tags/webrtc/"/>
    
    <category term="MSE" scheme="https://nick22nd.me/tags/MSE/"/>
    
    <category term="浏览器" scheme="https://nick22nd.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>音视频的采集, 编码和播放</title>
    <link href="https://nick22nd.me/posts/audio-video-encoder-starter/"/>
    <id>https://nick22nd.me/posts/audio-video-encoder-starter/</id>
    <published>2020-07-20T03:30:52.000Z</published>
    <updated>2024-05-27T11:00:34.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器上的音视频, 由于浏览器的严格限制, 只能在</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>样本文件<br>flv的样本文件 - 用于测试文件播放<br>yuv的样本文件 - 用于测试视频编码</p><h2 id="概念区分"><a href="#概念区分" class="headerlink" title="概念区分"></a>概念区分</h2><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>动态影像专家小组（英语：Moving Picture Experts Group，简称MPEG）为一源自ISO与IEC等国际组织的工作小组</p><h2 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h2><p>YUYV为YUV422采样的存储格式中的一种</p><h2 id="编码标准和实现"><a href="#编码标准和实现" class="headerlink" title="编码标准和实现"></a>编码标准和实现</h2><table><thead><tr><th>标准</th><th align="left">实现</th></tr></thead><tbody><tr><td>H.264</td><td align="left">x264</td></tr><tr><td>HEVC</td><td align="left">x265</td></tr></tbody></table><p>下一代标准: HEVC VP9<br>主流标准: H.264, MPEG4, VP8 </p><p>MP3既是音频编码, 也是一种文件格式</p><blockquote><p>MPEG-2 Audio Layer III是当今流行的一种数字音频编码和有损压缩格式</p></blockquote><h2 id="视频编码的控制"><a href="#视频编码的控制" class="headerlink" title="视频编码的控制"></a>视频编码的控制</h2><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/12373947">通过码率控制</a></p><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p><a href="http://www.libsdl.cn/sdl.php">SDL的概念</a></p><p>一个循环中</p><p>解码, 放入对应的buffer中</p><p>音视频同步</p><p>显示</p><p>END</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;浏览器上的音视频, 由于浏览器的严格限制, 只能在&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="音视频" scheme="https://nick22nd.me/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="入门" scheme="https://nick22nd.me/tags/%E5%85%A5%E9%97%A8/"/>
    
    <category term="概念" scheme="https://nick22nd.me/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的奇妙之旅(一)</title>
    <link href="https://nick22nd.me/posts/about-JavaScript-01/"/>
    <id>https://nick22nd.me/posts/about-JavaScript-01/</id>
    <published>2020-03-23T14:30:24.000Z</published>
    <updated>2024-06-02T11:03:11.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>JavaScript是当前最流行编程语言之一，JavaScript发展过程是怎么样的？它有哪些重要的发展阶段呢？</p><h3 id="初始时代"><a href="#初始时代" class="headerlink" title="初始时代"></a>初始时代</h3><p>JS是1995年网景为自家浏览器设计的用于网页交互的脚本语言. 其由Brendan Eich设计, 借鉴了Scheme , 当时如日中天的Java ,以及Smalltalk的特性.  所以JavaScript在主流编程语言显得很奇怪， 首先它带有很强的Scheme的印记，函数是第一公民，原型链；但是它也同样有着Java的一些标志。</p><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX(asynchronous Javascript and XML)可谓是Web发展的重要里程碑, 它极大地提高了Web应用程序的交互性。 浏览器在用户界面和服务器之间添加了一个抽象层面, 通过JavaScript来控制XMLHttpRequest对象，专门向服务器发送数据以及接受来自服务器的数据，并且在处理数据后并控制界面的变化反馈给用户。</p><p>AJAX的优点：</p><ul><li>减少了静态资源的重复请求，无缝刷新界面</li><li>提高了交互性，给予了前端构建富应用的能力</li></ul><h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><p>Jquery是将原生的JS的DOM操作进行封装, 正如其核心理念:Write less,Do more. 使用Jquery能大大地减少形如getElementById之类繁琐的操作, 以更加简洁的方式来操作DOM树以及进行Ajax的操作，同时解决了一部分浏览器兼容问题。</p><h3 id="前端框架与JS"><a href="#前端框架与JS" class="headerlink" title="前端框架与JS"></a>前端框架与JS</h3><p>浏览器的发展和JS的进化,以及三大框架出现时间,重要的节点如下:</p><ul><li>2008年的V8引擎发布</li><li>2008年ECMAScript 5.0发布</li><li>2009年AngularJS</li><li>2011年React</li><li>2014年Vue</li><li>2014年Angular2</li><li>2015年ECMAScript 6发布 ,且改名为ECMAScript 2015( ES6大多数情况就是指这一版本, 也有情况作为每年6月新标准的含义 )</li></ul><p>不大的时间跨度中，前端变化可谓是日新月异，各种框架层出不穷。</p><p>当前而言，前端情况基本稳定下来，当然，是相对之前的日新月异而言。</p><p>相较之前的变化：</p><ul><li>JS通过框架的分层架构的MV*，控制着ViewModel，声明式地完成业务代码，原有的DOM操作由框架来完成</li><li>组件化，非常有意义</li><li>另外React通过将JSX 转换成虚拟DOM，也就是将HTML转换成JS对象，对DOM有了完全的控制</li><li>ES6解决了许多过去语言层面的问题，一些新的特性对开发者更加友好。</li></ul><h3 id="后端NodeJS"><a href="#后端NodeJS" class="headerlink" title="后端NodeJS"></a>后端NodeJS</h3><p>在Node出现之前，JavaScript在后端上没有太多可说的，只是少部分作为脚本语言输出拼接html传递到浏览器。NodeJS的出现给JavaScript推开了另一个世界的大门，其作者本身是为了编写一个高性能服务器，选择JavaScript的原因是<br>    1. JavaScript在服务端没有历史包袱，可以尽情发挥<br>    2. V8引擎的高性能<br>    3. 异步IO和事件驱动的机制</p><p>Node作为「服务端语言」，其适用的场景是高I&#x2F;O的场景，然而现在Node更像是一个平台：活跃的社区，NPM中数量庞大的包。<br>主要应用：</p><ol><li>后端框架如Express,Next</li><li>前端工具链的基础设施</li><li>服务端渲染</li></ol><p>Node对Web相关的支持做得很好，而且与前端没有语言的切换成本，所以对于全栈定位非常合适，但是和传统后端语言Java以及Go比较还是有不少问题的。</p><h3 id="其它方面"><a href="#其它方面" class="headerlink" title="其它方面"></a>其它方面</h3><p>另外出现了很多类JS的语言如:</p><ul><li>TypeScript:其实是JS的超集, 可编译成JS代码. 由微软主持开发,其中有Anders Hejlsberg参与. TS写起来感觉更有安全感, 而且许多面向对象特性引入,让设计更加舒畅 .而且三大框架都在积极使用Typescript, 十分值得开发者学习.</li><li>Dart: 感觉更像是Java的JS, 很多人大概也是由于2019以来Flutter的火热才接触学习这门语言. 而且写Flutter应用的时候, 很多逻辑和React相似, 官方也提到了参考了React. 另外：Dart最初是google为了替代JS而推出的语言，曾经Chrome内建了Dart VM，但很遗憾没有太多后续，Chrome也在移除了Dart的支持。</li></ul><p>end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;JavaScript是当前最流行编程语言之一，JavaScript发展过程是怎么样的？它有哪些重要的发展阶段呢？&lt;/p&gt;
&lt;h3 id=&quot;初</summary>
      
    
    
    
    <category term="技术" scheme="https://nick22nd.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="https://nick22nd.me/tags/JavaScript/"/>
    
  </entry>
  
</feed>
